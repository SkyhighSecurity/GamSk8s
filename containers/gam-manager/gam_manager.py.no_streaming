import os
import time
import logging
import tempfile
import json
import zipfile
import tarfile
import shutil
import requests
import base64
import magic  # Use magic to detect file type
import pycdlib  # For ISO extraction
from requests_toolbelt.multipart.encoder import MultipartEncoder
from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename

# Initialize the Flask app
app = Flask(__name__)

# Set default environment variables
GAM_HOST = os.getenv('GAM_HOST', 'localhost')
GAM_PORT = os.getenv('GAM_PORT', '8080')
GAM_BACKEND = f"http://{GAM_HOST}:{GAM_PORT}"

GAM_USER = os.getenv('GAM_USER', 'testing')
GAM_PASSWORD = os.getenv('GAM_PASSWORD',  'testing')
GAM_AUTH = (GAM_USER, GAM_PASSWORD)

GAM_MALWARE_THRESHOLD = int(os.getenv('GAM_MALWARE_THRESHOLD', 60))
EXTRACT_PATH = os.getenv('EXTRACT_PATH', '/tmp')

# Configure logging to stdout/stderr
logging.basicConfig(level=logging.INFO)

# Utility function to extract archives
def extract_archive(file_path, extract_to):
    total_files = 0
    total_size = 0
    extracted_files = []

    # Use magic to identify the file type based on content
    file_type = magic.from_file(file_path, mime=True)

    # Handle ZIP files
    if file_type == 'application/zip':
        with zipfile.ZipFile(file_path, 'r') as archive:
            archive.extractall(extract_to)
            extracted_files = archive.namelist()
    # Handle TAR files (compressed or uncompressed)
    elif file_type in ['application/x-tar', 'application/gzip', 'application/x-bzip2', 'application/x-xz']:
        with tarfile.open(file_path, 'r:*') as archive:
            archive.extractall(extract_to)
            extracted_files = archive.getnames()
    # Handle ISO files
    elif file_type == 'application/x-iso9660-image':
        with pycdlib.PyCdlib() as iso:
            iso.open(file_path)
            iso_path = tempfile.mkdtemp(dir=extract_to)
            extract_iso(iso, iso_path)
            extracted_files = [os.path.join(dp, f) for dp, dn, fn in os.walk(iso_path) for f in fn]
    
    # Calculate the total number of files and bytes extracted
    for extracted_file in extracted_files:
        total_files += 1
        total_size += os.path.getsize(os.path.join(extract_to, extracted_file))

    return total_files, total_size, extracted_files

# Function to extract files from an ISO image
def extract_iso(iso, extract_to):
    for p in iso.list_children('/'):
        iso_file = p.fileid.decode('utf-8').strip()
        out_file = os.path.join(extract_to, iso_file)
        
        if p.is_file():
            iso.get_file_from_iso_fp(out_file, iso_path=iso_file)
        elif p.is_dir():
            os.makedirs(out_file, exist_ok=True)
            extract_iso(iso, out_file)

def encode_base64(content):
    """
    Encodes the given content to base64 format.
    """
    return base64.b64encode(content.encode('utf-8')).decode('utf-8')

# Utility function to scan a file using GAM backend
def scan_file_with_gam(file_data, file_name):
    source_url = f"http://0/file/{file_name}"
    encoded_source_url = encode_base64(source_url)

    metadata = json.dumps({"SourceURL": encoded_source_url})
    scan_request = {
        "meta": ("meta.json", metadata, "application/json"),
        "body": (file_name, file_data, "application/octet-stream")
    }

    encoder = MultipartEncoder(fields=scan_request)
    headers = {'Content-Type': encoder.content_type}

    try:
        response = requests.post(
            f"{GAM_BACKEND}/GAMScanServer/v1/scans",
            data=encoder,
            headers=headers,
            auth=GAM_AUTH,
            verify=False
        )
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        logging.error(f"Error scanning file: {str(e)}")
        return {'error': str(e)}

# Route to handle file uploads and scanning
@app.route('/scan', methods=['POST'])
def scan_file():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    
    uploaded_file = request.files['file']
    if uploaded_file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    filename = secure_filename(uploaded_file.filename)
    file_path = os.path.join(EXTRACT_PATH, filename)
    
    # Save the uploaded file to temporary storage
    uploaded_file.save(file_path)

    # Check if the file is an archive and extract if necessary
    total_files = 0
    total_size = 0
    extracted_files = []
    infected_files = []
    
    # Identify file type based on content, not extension
    file_type = magic.from_file(file_path, mime=True)
    if file_type in ['application/zip', 'application/x-tar', 'application/gzip', 'application/x-bzip2', 'application/x-xz', 'application/x-iso9660-image']:
        start_time = time.time()
        extract_to = tempfile.mkdtemp(dir=EXTRACT_PATH)
        total_files, total_size, extracted_files = extract_archive(file_path, extract_to)
        logging.info(f"Extracted archive {filename} with {total_files} files totaling {total_size} bytes")

        # Scan each extracted file
        for extracted_file in extracted_files:
            full_path = os.path.join(extract_to, extracted_file)

            if os.path.isfile(full_path):
                with open(full_path, 'rb') as f:
                    file_data = f.read()
                    scan_result = scan_file_with_gam(file_data, extracted_file)

                    malware_name = scan_result.get('MalwareName')
                    malware_probability = scan_result.get('MalwareProbability', 0)
                    if malware_name and malware_probability > GAM_MALWARE_THRESHOLD:
                        infected_files.append({
                            "file": extracted_file,
                            "malware_name": malware_name,
                            "malware_probability": malware_probability
                        })
            else:
                print(f"Skipping directory entry: {full_path}")

        shutil.rmtree(extract_to)
        elapsed_time = time.time() - start_time
        logging.info(f"Scanned archive {filename} in {elapsed_time:.2f} seconds: "
                     f"{len(infected_files)} infected out of {total_files}")

    else:
        # If the file is not an archive, scan it directly
        with open(file_path, 'rb') as f:
            file_data = f.read()
            scan_result = scan_file_with_gam(file_data, filename)

            malware_name = scan_result.get('MalwareName')
            malware_probability = scan_result.get('MalwareProbability', 0)
            if malware_name and malware_probability > GAM_MALWARE_THRESHOLD:
                infected_files.append({
                    "file": filename,
                    "malware_name": malware_name,
                    "malware_probability": malware_probability
                })

    # Return the results
    return jsonify({
        "infected_files": infected_files,
        "total_infected": len(infected_files),
        "not_infected": (total_files - len(infected_files))
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
